---
title: "construct.h & allocator.h - 构造、析构与内存分配"
date: "2025-02-12"
tags: ["stl", "memory", "placement-new", "allocator", "tag-dispatch"]
order: 5
toc: true
---

## 为什么需要分离内存分配和对象构造？

`vector` 管理内存时，**分配**和**构造**是分开的两步。想象 `vector<string>` 扩容后的内存布局：

```
容量 capacity = 8，已有 3 个元素：

| "aa" | "bb" | "cc" |  空  |  空  |  空  |  空  |  空  |
  ↑ 已构造的对象 ↑       ↑ 只是原始内存，没有对象 ↑
```

后面 5 个位置只是预留的原始内存，没有对象。你不能对空内存调用析构，也不能用赋值往空内存放对象——赋值要求那里已经有一个合法的对象。

所以容器需要四个独立操作：

| 操作 | 做什么 | 对应函数 |
|------|--------|---------|
| 分配内存 | 拿到一块原始内存 | `allocator::allocate` |
| 构造对象 | 在原始内存上创建对象 | `construct` |
| 析构对象 | 销毁对象但不释放内存 | `destroy` |
| 释放内存 | 归还内存给系统 | `allocator::deallocate` |

## placement new

普通的 `new` 做两件事：分配内存 + 调用构造函数。placement new 只做第二件——在你指定的地址上调用构造函数：

```cpp
// 普通 new：编译器自己找一块内存，然后构造对象
int* p = new int(42);

// placement new：你指定地址，它只负责构造
void* mem = malloc(sizeof(int));
int* p = new (mem) int(42);       // 在 mem 地址上构造 int
//            ^^^ 这里传入地址
```

`new (地址) 类型(参数)` 是 C++ 的内置语法。

## construct 的实现

封装 placement new，通过参数包 `Args&&...` 支持任意构造方式：

```cpp
template <class T, class... Args>
void construct(T* ptr, Args&&... args) {
  ::new ((void*)ptr) T(mystl::forward<Args>(args)...);
}
```

- `::new` 前面的 `::` 确保调用全局的 placement new，不会被类重载的 operator new 劫持
- `Args&&... args` 是参数包（variadic template），接受任意数量、任意类型的参数
- `forward` 完美转发每个参数

这样 `construct` 能处理各种构造场景：

```cpp
construct(ptr);                // 默认构造
construct(ptr, 42);            // 单参数构造
construct(ptr, "hello", 5);   // 多参数构造
```

## destroy 的实现

### 单个对象

直接调用析构函数：

```cpp
template <class T>
void destroy(T* ptr) {
  ptr->~T();
}
```

`ptr->~T()` 是显式调用析构函数的语法。普通情况下析构由编译器自动调用，但配合 placement new 时需要手动调用。

### 范围析构 + tag dispatch 优化

析构一个范围 `[first, last)` 内的所有对象：

```cpp
template <class ForwardIterator>
void destroy(ForwardIterator first, ForwardIterator last) {
  typedef typename iterator_traits<ForwardIterator>::value_type value_type;
  destroy_dispatch(first, last,
      bool_constant<std::is_trivially_destructible<value_type>::value>());
}
```

对于 **trivially destructible**（平凡可析构）的类型——如 `int`、`double`、指针——析构函数什么都不做，逐个调用是浪费。通过 tag dispatch 跳过：

```cpp
// 平凡类型：什么都不做
template <class ForwardIterator>
void destroy_dispatch(ForwardIterator first, ForwardIterator last,
                      true_type) {}

// 非平凡类型：逐个析构
template <class ForwardIterator>
void destroy_dispatch(ForwardIterator first, ForwardIterator last,
                      false_type) {
  for (; first != last; ++first)
    destroy(&*first);
}
```

这和 `iterator.h` 里 `distance` 的 tag dispatch 是同一个技巧——编译器在编译期选择正确的版本，运行时没有任何分支开销。

## allocator 的实现

allocator 是容器和内存管理之间的中间层。容器不直接调用 `new`/`delete`，而是通过 allocator，这样可以替换内存策略（内存池、共享内存等）。

我们实现的是最简单的默认分配器，底层就是 `::operator new` 和 `::operator delete`：

```cpp
template <class T>
class allocator {
public:
  typedef T         value_type;
  typedef T*        pointer;
  typedef const T*  const_pointer;
  typedef T&        reference;
  typedef const T&  const_reference;
  typedef size_t    size_type;
  typedef ptrdiff_t difference_type;

  static pointer allocate(size_type n) {
    return static_cast<pointer>(::operator new(n * sizeof(T)));
  }

  static void deallocate(pointer ptr, size_type /*n*/) {
    ::operator delete(ptr);
  }

  template <class... Args>
  static void construct(pointer ptr, Args&&... args) {
    mystl::construct(ptr, mystl::forward<Args>(args)...);
  }

  static void destroy(pointer ptr) {
    mystl::destroy(ptr);
  }

  static void destroy(pointer first, pointer last) {
    mystl::destroy(first, last);
  }
};
```

### typedef 的作用

allocator 内部的 `typedef` 暴露类型信息，让容器能通过统一的接口获取类型：

```cpp
template <class T, class Alloc = mystl::allocator<T>>
class vector {
  typedef typename Alloc::value_type  value_type;  // T
  typedef typename Alloc::pointer     pointer;      // T*
  typedef typename Alloc::size_type   size_type;    // size_t
};
```

### `::operator new` vs `new`

```cpp
// new 表达式：分配内存 + 构造对象（两步）
int* p = new int(42);

// ::operator new：只分配内存（一步），返回 void*
void* mem = ::operator new(sizeof(int));
```

allocator 用 `::operator new` 只分配原始内存，构造交给 `construct` 单独做。

## 容器如何使用这些工具

把它们串起来，`vector::push_back` 的流程大致是：

```cpp
void push_back(const T& value) {
  if (size == capacity) {
    // 1. 分配更大的内存
    T* new_mem = Alloc::allocate(capacity * 2);
    // 2. 把旧元素移动到新内存（construct + destroy）
    for (int i = 0; i < size; i++) {
      Alloc::construct(new_mem + i, mystl::move(old_mem[i]));
      Alloc::destroy(old_mem + i);
    }
    // 3. 释放旧内存
    Alloc::deallocate(old_mem, capacity);
  }
  // 4. 在末尾构造新元素
  Alloc::construct(mem + size, value);
  size++;
}
```

## 单元测试

### construct_test.cpp

```cpp
#include "construct.h"
#include <gtest/gtest.h>
#include <string>

TEST(ConstructTest, ConstructInt) {
  void* mem = ::operator new(sizeof(int));
  int* p = static_cast<int*>(mem);

  mystl::construct(p, 42);
  EXPECT_EQ(*p, 42);

  mystl::destroy(p);
  ::operator delete(mem);
}

TEST(ConstructTest, ConstructString) {
  void* mem = ::operator new(sizeof(std::string));
  std::string* p = static_cast<std::string*>(mem);

  mystl::construct(p, "hello");
  EXPECT_EQ(*p, "hello");

  mystl::destroy(p);
  ::operator delete(mem);
}

TEST(DestroyTest, DestroyRangeOfStrings) {
  const int n = 3;
  void* mem = ::operator new(sizeof(std::string) * n);
  std::string* arr = static_cast<std::string*>(mem);

  mystl::construct(arr, "aaa");
  mystl::construct(arr + 1, "bbb");
  mystl::construct(arr + 2, "ccc");

  mystl::destroy(arr, arr + n);
  ::operator delete(mem);
}

TEST(DestroyTest, DestroyRangeOfTrivialType) {
  int arr[] = {1, 2, 3};
  mystl::destroy(arr, arr + 3);  // no-op for int
  EXPECT_EQ(arr[0], 1);
}
```

### allocator_test.cpp

```cpp
#include "allocator.h"
#include <gtest/gtest.h>
#include <string>

TEST(AllocatorTest, ConstructAndDestroyString) {
  using Alloc = mystl::allocator<std::string>;
  std::string* p = Alloc::allocate(1);

  Alloc::construct(p, "hello");
  EXPECT_EQ(*p, "hello");

  Alloc::destroy(p);
  Alloc::deallocate(p, 1);
}

TEST(AllocatorTest, MultipleObjects) {
  using Alloc = mystl::allocator<std::string>;
  const int n = 3;
  std::string* arr = Alloc::allocate(n);

  Alloc::construct(arr, "aaa");
  Alloc::construct(arr + 1, "bbb");
  Alloc::construct(arr + 2, "ccc");

  EXPECT_EQ(arr[0], "aaa");
  EXPECT_EQ(arr[1], "bbb");
  EXPECT_EQ(arr[2], "ccc");

  Alloc::destroy(arr, arr + n);
  Alloc::deallocate(arr, n);
}

TEST(AllocatorTest, TypeTraits) {
  using Alloc = mystl::allocator<int>;
  static_assert(std::is_same<Alloc::value_type, int>::value);
  static_assert(std::is_same<Alloc::pointer, int*>::value);
  static_assert(std::is_same<Alloc::size_type, size_t>::value);
}
```

## 后续扩展

Phase 1 基础设施到这里全部完成。接下来进入 Phase 2 序列容器：

- **vector.h** — 动态数组，STL 中最常用的容器。它会用到我们实现的所有基础设施：allocator 管理内存、construct/destroy 管理对象生命周期、move/forward 实现高效的元素搬移、iterator_traits 支持泛型算法
